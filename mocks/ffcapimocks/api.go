// Code generated by mockery v1.0.0. DO NOT EDIT.

package ffcapimocks

import (
	context "context"

	fftypes "github.com/hyperledger/firefly-common/pkg/fftypes"
	ffcapi "github.com/hyperledger/firefly-transaction-manager/pkg/ffcapi"

	mock "github.com/stretchr/testify/mock"
)

// API is an autogenerated mock type for the API type
type API struct {
	mock.Mock
}

// BlockInfoByHash provides a mock function with given fields: ctx, req
func (_m *API) BlockInfoByHash(ctx context.Context, req *ffcapi.BlockInfoByHashRequest) (*ffcapi.BlockInfoByHashResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.BlockInfoByHashResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.BlockInfoByHashRequest) *ffcapi.BlockInfoByHashResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.BlockInfoByHashResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.BlockInfoByHashRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.BlockInfoByHashRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// BlockInfoByNumber provides a mock function with given fields: ctx, req
func (_m *API) BlockInfoByNumber(ctx context.Context, req *ffcapi.BlockInfoByNumberRequest) (*ffcapi.BlockInfoByNumberResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.BlockInfoByNumberResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.BlockInfoByNumberRequest) *ffcapi.BlockInfoByNumberResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.BlockInfoByNumberResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.BlockInfoByNumberRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.BlockInfoByNumberRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EventListenerAdd provides a mock function with given fields: ctx, req
func (_m *API) EventListenerAdd(ctx context.Context, req *ffcapi.EventListenerAddRequest) (*ffcapi.EventListenerAddResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.EventListenerAddResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.EventListenerAddRequest) *ffcapi.EventListenerAddResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.EventListenerAddResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.EventListenerAddRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.EventListenerAddRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EventListenerRemove provides a mock function with given fields: ctx, req
func (_m *API) EventListenerRemove(ctx context.Context, req *ffcapi.EventListenerRemoveRequest) (*ffcapi.EventListenerRemoveResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.EventListenerRemoveResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.EventListenerRemoveRequest) *ffcapi.EventListenerRemoveResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.EventListenerRemoveResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.EventListenerRemoveRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.EventListenerRemoveRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EventListenerVerifyOptions provides a mock function with given fields: ctx, options
func (_m *API) EventListenerVerifyOptions(ctx context.Context, options *fftypes.JSONAny) (*fftypes.JSONAny, error) {
	ret := _m.Called(ctx, options)

	var r0 *fftypes.JSONAny
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.JSONAny) *fftypes.JSONAny); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.JSONAny)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.JSONAny) error); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Events provides a mock function with given fields:
func (_m *API) Events() <-chan *ffcapi.Event {
	ret := _m.Called()

	var r0 <-chan *ffcapi.Event
	if rf, ok := ret.Get(0).(func() <-chan *ffcapi.Event); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *ffcapi.Event)
		}
	}

	return r0
}

// GasPriceEstimate provides a mock function with given fields: ctx, req
func (_m *API) GasPriceEstimate(ctx context.Context, req *ffcapi.GasPriceEstimateRequest) (*ffcapi.GasPriceEstimateResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.GasPriceEstimateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.GasPriceEstimateRequest) *ffcapi.GasPriceEstimateResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.GasPriceEstimateResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.GasPriceEstimateRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.GasPriceEstimateRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MethodCall provides a mock function with given fields: ctx, req
func (_m *API) MethodCall(ctx context.Context, req *ffcapi.MethodCallRequest) (*ffcapi.MethodCallResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.MethodCallResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.MethodCallRequest) *ffcapi.MethodCallResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.MethodCallResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.MethodCallRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.MethodCallRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewBlockHashes provides a mock function with given fields:
func (_m *API) NewBlockHashes() <-chan *ffcapi.BlockHashEvent {
	ret := _m.Called()

	var r0 <-chan *ffcapi.BlockHashEvent
	if rf, ok := ret.Get(0).(func() <-chan *ffcapi.BlockHashEvent); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *ffcapi.BlockHashEvent)
		}
	}

	return r0
}

// NextNonceForSigner provides a mock function with given fields: ctx, req
func (_m *API) NextNonceForSigner(ctx context.Context, req *ffcapi.NextNonceForSignerRequest) (*ffcapi.NextNonceForSignerResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.NextNonceForSignerResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.NextNonceForSignerRequest) *ffcapi.NextNonceForSignerResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.NextNonceForSignerResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.NextNonceForSignerRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.NextNonceForSignerRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TransactionPrepare provides a mock function with given fields: ctx, req
func (_m *API) TransactionPrepare(ctx context.Context, req *ffcapi.TransactionPrepareRequest) (*ffcapi.TransactionPrepareResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.TransactionPrepareResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.TransactionPrepareRequest) *ffcapi.TransactionPrepareResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.TransactionPrepareResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.TransactionPrepareRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.TransactionPrepareRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TransactionReceipt provides a mock function with given fields: ctx, req
func (_m *API) TransactionReceipt(ctx context.Context, req *ffcapi.TransactionReceiptRequest) (*ffcapi.TransactionReceiptResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.TransactionReceiptResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.TransactionReceiptRequest) *ffcapi.TransactionReceiptResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.TransactionReceiptResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.TransactionReceiptRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.TransactionReceiptRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TransactionSend provides a mock function with given fields: ctx, req
func (_m *API) TransactionSend(ctx context.Context, req *ffcapi.TransactionSendRequest) (*ffcapi.TransactionSendResponse, ffcapi.ErrorReason, error) {
	ret := _m.Called(ctx, req)

	var r0 *ffcapi.TransactionSendResponse
	if rf, ok := ret.Get(0).(func(context.Context, *ffcapi.TransactionSendRequest) *ffcapi.TransactionSendResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ffcapi.TransactionSendResponse)
		}
	}

	var r1 ffcapi.ErrorReason
	if rf, ok := ret.Get(1).(func(context.Context, *ffcapi.TransactionSendRequest) ffcapi.ErrorReason); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Get(1).(ffcapi.ErrorReason)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *ffcapi.TransactionSendRequest) error); ok {
		r2 = rf(ctx, req)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}
